                     +--------------------------+
       	       	     |		ECE 434		|
		     | PROJECT 2: USER PROGRAMS	|
		     | 	   DESIGN DOCUMENT     	|
		     +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Vineet Sepaha vs381@scarletmail.rutgers.edu
Kevin Wu kw346@scarletmail.rutgers.edu
Prit Modi pmm176@scarletmail.ruters.edu


---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

		    ---Work Division----

Vineet Sepaha:
- Process Termination Messages (50%)
- Argument Passing
- System calls: read(), write(), seek(), tell()
- Allowing/Denying writes to executables

Kevin Wu:
- Process Termination Messages (50%)
- System calls: create(), remove(), open(), filesize(), (close, exit)
- syscall_handler()
- Worked on merging the system calls into syscall.c
and fixed errors received from doing so.

Prit Modi:
- System calls: halt(), exec(), wait() (exit, close)
- Synchronization between parent and child

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

- http://www.scs.stanford.edu/10wi-cs140/labs/10wi-proj2.pdf
- http://courses.cs.vt.edu/~cs3204/fall2009/pintos-vt-local/Project2Session.pdf

			   ARGUMENT PASSING
			   ================
(Vineet - Done)
---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

In process.c:
    static void get_args(char * cmd_string, char* argv[], int *argc)
/* The purpose of this function was to implement string parsing */



---- ALGORITHMS ---- (Done)

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?

    One of the most important things to do for argument passing was to setup 
the stack. We implemented the stack in setup_stack().
    In our implementation, we first start out with process_execute() which is used
for calling start_process(). This function is then used to call the load() function.
The load() function is responsible for implementing parsing to the command line 
string which it is passed. The load function calls a function which we created called
get_args(); this function is used to parse the string and use strtok_r() to get each 
of the arguments, save them as tokens and place them in the variable we created called 
argv[] and also place the number of arguments into a variable called argc. In the get_args()
function we read the arguments left to right into argv[] (However, when we later pushed them
onto the stack, they were pushed in from right to left). After get_args() was implemented,
we return to the load() function and call setup_stack().
    As previously mentioned, this is where we pushed the arguments onto the stack. The 
first thing we did was allocate memory for the stack by using realloc(). Next, we pushed the
arguments in the reverse orderon to the stack. After this is done we implement a word align 
to optimize the stack. Then we pushed in a sentinel value of zero onto the stack so
the kernel would know when we were done pushing in the arguments. After this was done,
we started to decrement the stack pointer by 4 and push on the addresses for each of the
arguments onto the stack.The last two things we pushed onto the stack was a pointer to where
the address was stored for the first argument and then we pushed on a value of zero onto
the stack to show that we were finished with setting up the stack. 

---- RATIONALE ---- (Done)

>> A3: Why does Pintos implement strtok_r() but not strtok()?

    Pintos implements strtok_r() instead of strtok() because strtok() skips over the first 
argument in while parsing the string. The strtok_r() function however, returns a pointer
to the first arguments(token). When there are no more tokens remaining, it returns a null pointer.
This is what we needed in order for argument passing to work successfully.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

    One of the advantages of the Unix approach is that less time is spent in the 
kernel. The advantage of this is that it is every expensive to run in kernel mode 
and if a problem occurs while in kernel mode, the entire PC will halt.
    The second advantage of the Unix approach is that it is much safer to use 
shell parsing operations. This is because the shell would be able to check for  
an unsafe command line before it goes to the kernel. This will prevent errors
from occuring in the kernel.

			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----
(We each work on what we added/changed)

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct file* file_check (int fd)
{
  struct thread *cur = thread_current();
  struct list_elem *e =  list_head (&cur->file_list);

  while ((e = list_next (e)) != list_end (&cur->file_list)){
    struct process_file *pf = list_entry (e, struct process_file, elem);
    if (fd == pf->fd) {
	  return pf->file;
	}
    e = list_next(e);
  }

  return NULL;
}
/* The struct is used to be able to reference the file that is going to be 
used. */
 

static struct lock LOCK; 
/* LOCK is implemented to prevent interrupts during the critical section of a system call */

typedef int pid_t;
/* To define certain parameters as threads */



>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

---- ALGORITHMS ----

(Vineet)
>> B3: Describe your code for reading and writing user data from the
>> kernel.

(Kevin - Done)
>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

    Within our implementation, the maximum size of a page is exactly
4,096 bytes. Thus, if a system call that creates a full page and
is copied there would be in total 2 full pages. As such, the maximum 
possible number of inspections would be 2. The least possible number 
of inspections would be 1. 

    In the use case of a system call only copying 2 bytes of data,
it is the same as previous, with maximum possible inspections
being 2 and minimum possible inspections at 1. The only slight
difference is that the possibility of needing 2 inspections
is much lower than the previous use case.

    A possible way to improve upon these numbers is to simply
remove checking the addresses for read and write. If this
is the case, the system calls would continue untill an
error, like page fault, occurs. In such an instance, 
the interrupt handler would be implemented in such a manner
that is would handle these errors appropriately. As such,
there wouldn't be a need for any inspections. 


(Prit)
>> B5: Briefly describe your implementation of the "wait" system call.

(Kevin)
>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

Within our implementation, our primary method of dealing with
bad pointers is by using the function we created, validaddr().
Before any of the system calls can even begin, we check the
address of the pointer and makes sure it is valid before we
proceed. As such, we essentially prevent bad pointers from
ever having any interaction with our system calls. Thus,
there is no obscurity towards the primary function of code and
no temporarily allocated resources are used.

Example:
	
	system call exec is made

	The syscall handler passes in the arguments respectively.
	The function exec is called upon with the passed 
	arguments. Before any execution of code is performed,
	the function validaddr() is executed to check for valid
	pointer address. If it is a bad pointer, thread_exit() is
	called. If it isn't a bad pointer, the function continues 
	normally.

---- SYNCHRONIZATION ----

(Prit)
>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?

(Prit)
>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

---- RATIONALE ---- (Teamwork)

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Any other comments?
